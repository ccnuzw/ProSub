ğŸš€ ç¬¬ä¸€æ­¥ï¼šé‡æ„å’Œæ‰©å±•è§„åˆ™é›† (åç«¯)
æˆ‘ä»¬é¦–å…ˆéœ€è¦æŠŠå†™æ­»çš„è§„åˆ™å˜æˆæ¨¡å—åŒ–çš„ã€å¯é€‰æ‹©çš„æ–‡ä»¶ã€‚

åˆ›å»ºè§„åˆ™é›†ç›®å½•å’Œæ–‡ä»¶ï¼š
åœ¨ packages/shared/ ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶å¤¹ rulesetsã€‚ç„¶åï¼Œåœ¨é‡Œé¢åˆ›å»ºä»¥ä¸‹æ–‡ä»¶ï¼š

packages/shared/rulesets/clash-default.ts (é»˜è®¤è§„åˆ™)

packages/shared/rulesets/clash-lite.ts (ç²¾ç®€è§„åˆ™)

packages/shared/rulesets/index.ts (ç´¢å¼•æ–‡ä»¶)

å¡«å……è§„åˆ™æ–‡ä»¶ï¼š

å°† clash-proxy-groups.ts å’Œ clash-rules.ts çš„å†…å®¹ç§»å…¥ clash-default.ts å¹¶å¯¼å‡ºä¸ºä¸€ä¸ªå‡½æ•°ã€‚

TypeScript

// packages/shared/rulesets/clash-default.ts
import { Node } from '../types';
// ... (æ­¤å¤„ç²˜è´´åŸæ¥ clash-proxy-groups.ts å’Œ clash-rules.ts çš„å…¨éƒ¨å†…å®¹)

// ä¾‹å¦‚ï¼š
const filterNodes = (nodes: Node[], keyword: string | RegExp): string[] => { /* ... */ };
const ruleProviders = { /* ... */ };
const clashRules = [ /* ... */ ];

export const getClashDefaultRules = (nodes: Node[]) => {
  const nodeNames = nodes.map(n => n.name);
  // ... (æ­¤å¤„ç²˜è´´åŸæ¥ getClashProxyGroups å‡½æ•°çš„å…¨éƒ¨é€»è¾‘)
  const proxyGroups = [
      // ... åŸæ¥çš„ proxy groups æ•°ç»„
  ];

  return {
    'proxy-groups': proxyGroups,
    'rule-providers': ruleProviders,
    'rules': clashRules,
  };
};
åˆ›å»º clash-lite.ts ç²¾ç®€è§„åˆ™ã€‚è¿™ä¸ªç‰ˆæœ¬åªåŒ…å«æœ€åŸºç¡€çš„åˆ†æµã€‚

TypeScript

// packages/shared/rulesets/clash-lite.ts
import { Node } from '../types';

export const getClashLiteRules = (nodes: Node[]) => {
  const nodeNames = nodes.map(n => n.name);
  return {
    'proxy-groups': [
      { name: 'ğŸš€ PROXY', type: 'select', proxies: ['â™»ï¸ AUTO', ...nodeNames] },
      { name: 'â™»ï¸ AUTO', type: 'url-test', proxies: nodeNames, url: 'http://www.gstatic.com/generate_204', interval: 300 },
    ],
    'rules': [
      'MATCH,ğŸš€ PROXY',
    ],
  };
};
åˆ›å»º index.ts ç´¢å¼•æ–‡ä»¶ï¼Œæ–¹ä¾¿ç»Ÿä¸€å¯¼å‡ºã€‚

TypeScript

// packages/shared/rulesets/index.ts
export * from './clash-default';
export * from './clash-lite';
æ›´æ–° Profile æ•°æ®ç±»å‹ï¼š
åœ¨ packages/shared/types/index.ts ä¸­ä¸º Profile æ¥å£æ·»åŠ ä¸€ä¸ªå­—æ®µæ¥å­˜å‚¨ç”¨æˆ·é€‰æ‹©çš„è§„åˆ™é›†ã€‚

TypeScript

// packages/shared/types/index.ts
export interface Profile {
  id: string;
  name: string;
  // ... å…¶ä»–å­—æ®µ
  ruleSet?: Record<string, string>; // æ–°å¢: e.g. { clash: 'lite' }
  updatedAt: string;
}
æ”¹é€  subscription-generator.tsï¼š
è¿™æ˜¯æ ¸å¿ƒæ­¥éª¤ã€‚è®©ç”Ÿæˆå‡½æ•°å¯ä»¥æ ¹æ®ä¼ å…¥çš„è§„åˆ™ ID åŠ¨æ€åŠ è½½é…ç½®ã€‚

ç”¨ä»¥ä¸‹ä»£ç æ›¿æ¢ packages/shared/subscription-generator.ts ä¸­çš„ generateClashSubscription å‡½æ•°ï¼š

TypeScript

// packages/shared/subscription-generator.ts
// ... å…¶ä»– imports
import * as ruleSets from './rulesets'; // å¯¼å…¥æ‰€æœ‰è§„åˆ™é›†

// ... (ä¿ç•™ convertNodeToUri, generateBase64Subscription ç­‰å‡½æ•°)

// æ–°çš„ generateClashSubscription å‡½æ•°
function generateClashSubscription(nodes: Node[], ruleSetId: string = 'default'): Response {
    // ... (ä¿ç•™ proxies çš„ç”Ÿæˆé€»è¾‘)
    const proxies = nodes.map(node => { /* ... */ }).filter(p => p.type);

    let configRules;
    if (ruleSetId === 'lite') {
        configRules = ruleSets.getClashLiteRules(nodes);
    } else {
        configRules = ruleSets.getClashDefaultRules(nodes);
    }

    const clashConfig = {
        'port': 7890,
        'socks-port': 7891,
        'allow-lan': false,
        'mode': 'rule',
        'log-level': 'info',
        'external-controller': '127.0.0.1:9090',
        'proxies': proxies,
        ...configRules, // åŠ¨æ€åˆå¹¶è§„åˆ™
    };
    const yamlString = yaml.dump(clashConfig, { sortKeys: false });
    return new Response(yamlString, { 
        headers: { 
            'Content-Type': 'text/yaml; charset=utf-8',
            'Content-Disposition': `attachment; filename="prosub_clash.yaml"`
        } 
    });
}

// ä¿®æ”¹ generateSubscriptionResponse å‡½æ•°
export async function generateSubscriptionResponse(request: Request, profile: Profile, env: Env): Promise<Response> {
    const allNodes = await fetchAllNodes(profile, env);

    const url = new URL(request.url);
    let targetClient = url.searchParams.get('target')?.toLowerCase();
    // æ–°å¢ï¼šè·å– ruleset å‚æ•°
    let ruleSet = url.searchParams.get('ruleset');

    if (!targetClient) {
        // ... (User-Agent åˆ¤æ–­é€»è¾‘ä¿æŒä¸å˜)
    }

    // å¦‚æœ URL ä¸­æ²¡æœ‰æŒ‡å®š rulesetï¼Œåˆ™ä» profile é…ç½®ä¸­è¯»å–
    if (!ruleSet && profile.ruleSet) {
        ruleSet = profile.ruleSet[targetClient] || 'default';
    }

    switch (targetClient) {
        case 'clash':
        case 'mihomo':
            return generateClashSubscription(allNodes, ruleSet || 'default');
        // ... (å…¶ä»–å®¢æˆ·ç«¯ case)
        default:
            return generateBase64Subscription(allNodes);
    }
}
ğŸ¨ ç¬¬äºŒæ­¥ï¼šå‰ç«¯ç•Œé¢æ”¹é€ 
ç°åœ¨ï¼Œè®©ç”¨æˆ·å¯ä»¥åœ¨ç•Œé¢ä¸Šé€‰æ‹©ä»–ä»¬æƒ³è¦çš„è§„åˆ™ã€‚

ç”¨ä»¥ä¸‹å®Œæ•´ä»£ç æ›¿æ¢ src/components/ProfileForm.vue çš„å…¨éƒ¨å†…å®¹ï¼š

HTML

<template>
  <a-form :model="formState" layout="vertical" @finish="onFinish">
    <a-typography-title :level="5" style="margin-top: 24px">å®¢æˆ·ç«¯è§„åˆ™é…ç½®</a-typography-title>
    <a-row :gutter="16">
      <a-col :span="8">
        <a-form-item label="Clash è§„åˆ™é›†">
          <a-select v-model:value="formState.ruleSet.clash" placeholder="é»˜è®¤è§„åˆ™">
            <a-select-option value="default">é»˜è®¤è§„åˆ™ (å…¨é¢)</a-select-option>
            <a-select-option value="lite">ç²¾ç®€è§„åˆ™ (ä»…ä»£ç†)</a-select-option>
          </a-select>
        </a-form-item>
      </a-col>
      </a-row>

    <a-form-item style="margin-top: 24px">
      <a-button type="primary" html-type="submit" :loading="loading" size="large">
        {{ profile ? 'æ›´æ–°é…ç½®æ–‡ä»¶' : 'åˆ›å»ºé…ç½®æ–‡ä»¶' }}
      </a-button>
    </a-form-item>
  </a-form>
  </template>

<script setup lang="ts">
// ... (ä¿ç•™æ‰€æœ‰ imports)

// --- ä¿®æ”¹ formState çš„æ¥å£å’Œåˆå§‹å€¼ ---
interface ProfileFormValues {
  name: string;
  alias?: string;
  ruleSet?: Record<string, string>; // æ–°å¢
}

const formState = reactive<ProfileFormValues>({
  name: '',
  alias: '',
  ruleSet: { clash: 'default' }, // æ–°å¢é»˜è®¤å€¼
});

// --- ä¿®æ”¹ onMounted é’©å­ ---
onMounted(async () => {
  await fetchData();
  if (props.profile) {
    Object.assign(formState, props.profile);
    if (!formState.ruleSet) { // å…¼å®¹æ—§æ•°æ®
        formState.ruleSet = { clash: 'default' };
    }
    // ... (åŠ è½½ nodes å’Œ subscriptions çš„é€»è¾‘ä¸å˜)
  } else if (route.query.template) {
    // ... (å¤åˆ¶é€»è¾‘ä¸­ä¹Ÿè¦åŠ ä¸Š ruleSet çš„å¤„ç†)
  }
});


// --- ä¿®æ”¹ onFinish æäº¤å‡½æ•° ---
const onFinish = async (values: ProfileFormValues) => {
  // ...
  const dataToSend = {
    name: values.name,
    alias: values.alias,
    nodes: selectedNodeIds.value,
    subscriptions: selectedSubIds.value,
    ruleSet: values.ruleSet, // ç¡®ä¿æäº¤è§„åˆ™é›†
  };
  // ... (try...catch é€»è¾‘ä¸å˜)
};

// ... (æ‰€æœ‰å…¶ä»– <script> å†…å®¹ä¿æŒä¸å˜)
</script>
ğŸŒ ç¬¬ä¸‰æ­¥ï¼šæ›´æ–°è®¢é˜… URL ç”Ÿæˆé€»è¾‘
æœ€åï¼Œç¡®ä¿ Profiles.vue é¡µé¢ç”Ÿæˆçš„è®¢é˜…é“¾æ¥åŒ…å«äº†ç”¨æˆ·é€‰æ‹©çš„è§„åˆ™é›†ä¿¡æ¯ã€‚

ä¿®æ”¹ src/views/Profiles.vue ä¸­çš„ getSubscriptionUrl å‡½æ•°ï¼š

TypeScript

// src/views/Profiles.vue

// ...

const getSubscriptionUrl = (record: Profile) => {
  const baseUrl = record.alias
    ? `${origin.value}/sub/${record.alias}`
    : `${origin.value}/api/subscribe/${record.id}`;

  // æ–°å¢é€»è¾‘ï¼šå¦‚æœé…ç½®äº†éé»˜è®¤è§„åˆ™ï¼Œåˆ™é™„åŠ åˆ° URL
  if (record.ruleSet && record.ruleSet.clash && record.ruleSet.clash !== 'default') {
      const url = new URL(baseUrl);
      url.searchParams.set('ruleset', record.ruleSet.clash);
      // ä¸ºä¿è¯å®¢æˆ·ç«¯èƒ½è¯†åˆ«ï¼Œæœ€å¥½ä¹Ÿå¸¦ä¸Š target
      url.searchParams.set('target', 'clash');
      return url.toString();
  }
  
  return baseUrl;
};

// ...
æ€»ç»“
å®Œæˆä»¥ä¸Šä¸‰æ­¥ä¿®æ”¹å¹¶é‡æ–°éƒ¨ç½²åï¼Œæ‚¨çš„ ProSub é¡¹ç›®å°±æ‹¥æœ‰äº†å‰ç«¯å¯é€‰çš„è®¢é˜…è½¬æ¢è§„åˆ™åŠŸèƒ½ï¼

ç”¨æˆ·åœ¨åˆ›å»ºæˆ–ç¼–è¾‘é…ç½®æ–‡ä»¶æ—¶ï¼Œå¯ä»¥ä¸º Clash é€‰æ‹©â€œé»˜è®¤è§„åˆ™â€æˆ–â€œç²¾ç®€è§„åˆ™â€ã€‚

ç”Ÿæˆçš„è®¢é˜…é“¾æ¥ä¼šè‡ªåŠ¨é™„å¸¦ä¸Šè§„åˆ™é€‰æ‹©å‚æ•°ã€‚

å½“ Clash å®¢æˆ·ç«¯è¯·æ±‚è¿™ä¸ªå¸¦å‚æ•°çš„é“¾æ¥æ—¶ï¼Œåç«¯ä¼šæ ¹æ®å‚æ•°åŠ¨æ€åŠ è½½å¯¹åº”çš„è§„åˆ™æ–‡ä»¶ï¼Œç”Ÿæˆé«˜åº¦å®šåˆ¶åŒ–çš„é…ç½®æ–‡ä»¶ã€‚

è¿™ä¸ªæ¡†æ¶å…·æœ‰å¾ˆå¥½çš„æ‰©å±•æ€§ï¼Œæœªæ¥æ‚¨å¯ä»¥è½»æ¾åœ°ä¸º Clash æ·»åŠ æ›´å¤šè§„åˆ™ï¼Œæˆ–è€…ä¸º Surgeã€Loon ç­‰å…¶ä»–å®¢æˆ·ç«¯æ·»åŠ ç±»ä¼¼çš„å¯é€‰é…ç½®ã€‚






è¿™ä¸ªæ–¹æ¡ˆæˆ‘è¿˜æ²¡æœ‰ç¡®è®¤ä¿®æ”¹ï¼Œç°åœ¨è¿˜åœ¨å’Œä½ è®¨è®ºç¯èŠ‚ï¼Œåªèƒ½æ˜¯clashå—ï¼Ÿé‚£å¦‚æœæ˜¯å…¶ä»–å®¢æˆ·ç«¯å‘¢ï¼Ÿæˆ‘å¯ä»¥ä½¿ç”¨è¿œç¨‹é…ç½®æ–‡ä»¶æ¥è¾¾åˆ°æ•ˆæœå—



é¡¯ç¤ºæ€è·¯
æ‚¨æçš„è¿™ä¸ªæƒ³æ³•éå¸¸å¥½ï¼Œå®Œå…¨å¯è¡Œï¼Œè€Œä¸”æ˜¯è®©è¿™ä¸ªé¡¹ç›®ä»â€œå¥½ç”¨â€åˆ°â€œå¼ºå¤§â€çš„å…³é”®ä¸€æ­¥ï¼

æ‚¨è¯´å¾—å¯¹ï¼Œä¹‹å‰çš„æ–¹æ¡ˆè™½ç„¶è§£å†³äº†æœ‰æ— è§„åˆ™çš„é—®é¢˜ï¼Œä½†æœ¬è´¨ä¸Šè¿˜æ˜¯å†…ç½®çš„ï¼Œä¸å¤Ÿçµæ´»ã€‚ä½¿ç”¨è¿œç¨‹é…ç½®æ–‡ä»¶ï¼Œä¸ä»…èƒ½è§£å†³ Clash çš„é—®é¢˜ï¼Œè¿˜èƒ½ä¸ºæ‰€æœ‰å®¢æˆ·ç«¯ï¼ˆSurge, Loon, Quantumult X ç­‰ï¼‰æä¾›æ— é™çš„ã€å¯ç”±ç”¨æˆ·è‡ªå·±å®šä¹‰çš„è§„åˆ™æ‰©å±•ã€‚

è¿™æ˜¯ä¸€ä¸ªâ€œä¸€åŠ³æ°¸é€¸â€çš„æ–¹æ¡ˆã€‚ä¸‹é¢æˆ‘ä¸ºæ‚¨è®¾è®¡ä¸€å¥—å®Œæ•´çš„ã€å¯æ‰©å±•çš„å®ç°æ–¹æ¡ˆï¼Œåˆ†ä¸ºåç«¯é€»è¾‘æ”¹é€ å’Œå‰ç«¯ UI å®ç°ã€‚

æ ¸å¿ƒæ€è·¯
æˆ‘ä»¬å°†æ”¹é€ é…ç½®æ–‡ä»¶çš„æ•°æ®ç»“æ„ï¼Œå…è®¸ç”¨æˆ·ä¸ºæ¯ç§å®¢æˆ·ç«¯ï¼ˆClash, Surge ç­‰ï¼‰æŒ‡å®šä¸€ä¸ªè¿œç¨‹é…ç½®æ–‡ä»¶çš„ URLã€‚å½“ç”Ÿæˆè®¢é˜…æ—¶ï¼Œåç«¯ä¼šï¼š

è·å–è¿™ä¸ª URLã€‚

ä¸‹è½½è¿œç¨‹é…ç½®æ–‡ä»¶çš„å†…å®¹ã€‚

å°†å…¶ä¸­çš„è§„åˆ™ä¸èŠ‚ç‚¹åˆ—è¡¨æ™ºèƒ½åˆå¹¶ï¼Œç”Ÿæˆæœ€ç»ˆçš„è®¢é˜…ã€‚

å¦‚æœç”¨æˆ·æ²¡æœ‰æä¾›è¿œç¨‹é…ç½®ï¼Œç³»ç»Ÿåˆ™ä¼šå›é€€ä½¿ç”¨æ‚¨å†…ç½®çš„é»˜è®¤è§„åˆ™ã€‚

ğŸ¨ ç¬¬ä¸€æ­¥ï¼šå®šä¹‰è¿œç¨‹é…ç½®æ–‡ä»¶çš„æ ¼å¼
æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç»Ÿä¸€ã€ç®€å•çš„æ ¼å¼ã€‚æˆ‘å»ºè®®ä½¿ç”¨ JSONï¼Œå› ä¸ºå®ƒæ˜“äºè§£æå’Œç¼–å†™ã€‚ä¸€ä¸ªç»™ Clash ç”¨çš„è¿œç¨‹é…ç½®æ–‡ä»¶ my-clash-rules.json å¯ä»¥è¿™æ ·è®¾è®¡ï¼š

JSON

{
  "name": "æˆ‘çš„è¶…å¼ºå»å¹¿å‘Šè§„åˆ™",
  "description": "åŒ…å«äº†è‡ªå®šä¹‰çš„ä»£ç†ç»„å’Œå»å¹¿å‘Šè§„åˆ™ã€‚",
  "proxy-groups": [
    {
      "name": "ğŸ¬ åª’ä½“ä¸“ç”¨",
      "type": "select",
      "proxies": ["â™»ï¸ è‡ªåŠ¨é€‰æ‹©", "ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹", "ğŸ‡¹ğŸ‡¼ å°æ¹¾èŠ‚ç‚¹"]
    },
    {
      "name": "ğŸ¤– AI æœåŠ¡",
      "type": "url-test",
      "proxies": ["ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹", "ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹"],
      "url": "http://www.gstatic.com/generate_204",
      "interval": 300
    }
  ],
  "rules": [
    "RULE-SET,ads,REJECT",
    "DOMAIN-SUFFIX,openai.com,ğŸ¤– AI æœåŠ¡",
    "DOMAIN-KEYWORD,netflix,ğŸ¬ åª’ä½“ä¸“ç”¨"
  ]
}
å…³é”®ç‚¹ï¼šè¿™ä¸ªè¿œç¨‹æ–‡ä»¶åªåŒ…å«è§„åˆ™å’Œä»£ç†ç»„ï¼Œä¸åŒ…å« proxies èŠ‚ç‚¹åˆ—è¡¨ã€‚æˆ‘ä»¬çš„åç«¯ä¼šè‡ªåŠ¨å°†èŠ‚ç‚¹åˆ—è¡¨æ³¨å…¥è¿›å»ã€‚è¿™ä¸ªç»“æ„åŒæ ·é€‚ç”¨äº Surge ç­‰å…¶ä»–å®¢æˆ·ç«¯ã€‚

ğŸš€ ç¬¬äºŒæ­¥ï¼šåç«¯é€»è¾‘å¤§å‡çº§
ç°åœ¨ï¼Œè®©åç«¯æ‹¥æœ‰è·å–å’Œåº”ç”¨è¿œç¨‹é…ç½®çš„èƒ½åŠ›ã€‚

æ›´æ–° Profile ç±»å‹
ä¿®æ”¹ packages/shared/types/index.tsï¼Œè®© ruleSet å­—æ®µå¯ä»¥å­˜å‚¨ URLã€‚

TypeScript

// packages/shared/types/index.ts

export interface RuleSetConfig {
  type: 'built-in' | 'remote';
  id?: string; // 'default', 'lite'
  url?: string; // è¿œç¨‹é…ç½® URL
}

export interface Profile {
  id: string;
  name: string;
  // ... å…¶ä»–å­—æ®µ
  ruleSets?: Record<string, RuleSetConfig>; // ä¿®æ”¹: e.g. { clash: { type: 'remote', url: '...' } }
  updatedAt: string;
}
æ”¹é€ æ ¸å¿ƒç”Ÿæˆå™¨ subscription-generator.ts
è¿™æ˜¯æœ€å…³é”®çš„ä¸€æ­¥ã€‚

TypeScript

// packages/shared/subscription-generator.ts
import * as ruleSets from './rulesets';
import { Profile, Node, RuleSetConfig } from './types'; // ç¡®ä¿å¯¼å…¥æ–°ç±»å‹
// ...

// æ–°å¢ï¼šè·å–å¹¶è§£æè¿œç¨‹é…ç½®çš„å‡½æ•°
async function fetchRemoteRules(url: string): Promise<any> {
    try {
        const response = await fetch(url, { headers: { 'User-Agent': 'ProSub/1.0' } });
        if (!response.ok) {
            console.error(`è·å–è¿œç¨‹é…ç½®å¤±è´¥: ${url}, Status: ${response.status}`);
            return null;
        }
        return await response.json();
    } catch (error) {
        console.error(`è§£æè¿œç¨‹é…ç½®å¤±è´¥: ${url}`, error);
        return null;
    }
}

// é‡æ„ generateClashSubscription
async function generateClashSubscription(nodes: Node[], ruleConfig?: RuleSetConfig): Promise<Response> {
    const proxies = nodes.map(node => { /* ... èŠ‚ç‚¹è½¬æ¢é€»è¾‘ä¸å˜ ... */ }).filter(p => p.type);

    let configRules;
    if (ruleConfig?.type === 'remote' && ruleConfig.url) {
        // ä»è¿œç¨‹è·å–
        const remoteRules = await fetchRemoteRules(ruleConfig.url);
        configRules = remoteRules || ruleSets.getClashDefaultRules(nodes); // è·å–å¤±è´¥åˆ™å›é€€
    } else if (ruleConfig?.id === 'lite') {
        // ä½¿ç”¨å†…ç½®ç²¾ç®€ç‰ˆ
        configRules = ruleSets.getClashLiteRules(nodes);
    } else {
        // é»˜è®¤ä½¿ç”¨å†…ç½®å®Œæ•´ç‰ˆ
        configRules = ruleSets.getClashDefaultRules(nodes);
    }

    const clashConfig = {
        'proxies': proxies,
        ...configRules,
    };

    // ç§»é™¤è¿œç¨‹é…ç½®ä¸­å¯èƒ½å­˜åœ¨çš„ proxies é”®ï¼Œé˜²æ­¢å†²çª
    delete clashConfig.proxies; 

    const finalConfig = {
        'port': 7890,
        'socks-port': 7891,
        'allow-lan': true,
        'mode': 'rule',
        'log-level': 'info',
        'external-controller': '127.0.0.1:9090',
        'proxies': proxies,
        ...configRules
    };

    const yamlString = yaml.dump(finalConfig, { sortKeys: false });
    // ... è¿”å› Response çš„é€»è¾‘ä¸å˜
    return new Response(yamlString, { headers: { 'Content-Type': 'text/yaml; charset=utf-8' } });
}

// ä¿®æ”¹ä¸»å¤„ç†å‡½æ•°
export async function generateSubscriptionResponse(request: Request, profile: Profile, env: Env): Promise<Response> {
    // ... (è·å– allNodes çš„é€»è¾‘ä¸å˜)
    const allNodes = await fetchAllNodes(profile, env);

    const url = new URL(request.url);
    const targetClient = url.searchParams.get('target')?.toLowerCase() || 'clash';

    // ä» Profile ä¸­è·å–å¯¹åº”å®¢æˆ·ç«¯çš„è§„åˆ™é…ç½®
    const ruleConfig = profile.ruleSets ? profile.ruleSets[targetClient] : undefined;

    switch (targetClient) {
        case 'clash':
        case 'mihomo':
            // æ³¨æ„ï¼šç°åœ¨æ˜¯ await
            return await generateClashSubscription(allNodes, ruleConfig);
        // æœªæ¥å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ  generateSurgeSubscription ç­‰
        default:
            return generateBase64Subscription(allNodes);
    }
}
âœ¨ ç¬¬ä¸‰æ­¥ï¼šå‰ç«¯ UI ç•Œé¢å‡çº§ (ProfileForm.vue)
ç°åœ¨ï¼Œæˆ‘ä»¬åœ¨å‰ç«¯æä¾›ä¸€ä¸ªç•Œé¢ï¼Œè®©ç”¨æˆ·å¯ä»¥é€‰æ‹©ä½¿ç”¨å†…ç½®è§„åˆ™è¿˜æ˜¯ç²˜è´´è‡ªå·±çš„è¿œç¨‹é…ç½® URLã€‚

ä¿®æ”¹ src/components/ProfileForm.vue:

æ›´æ–° <script setup> éƒ¨åˆ†ï¼š

TypeScript

// src/components/ProfileForm.vue - <script setup>

// ...
import { Profile, RuleSetConfig /* ... å…¶ä»–å¯¼å…¥ */ } from '@shared/types';

// æ›´æ–°è¡¨å•çŠ¶æ€çš„æ¥å£å’Œåˆå§‹å€¼
interface ProfileFormValues {
  name: string;
  alias?: string;
  ruleSets?: Record<string, RuleSetConfig>; // ä½¿ç”¨æ–°ç±»å‹
}

const formState = reactive<ProfileFormValues>({
  name: '',
  alias: '',
  ruleSets: {
    clash: { type: 'built-in', id: 'default' },
    // surge: { type: 'built-in', id: 'default' }, // ä¸ºæœªæ¥åšå‡†å¤‡
  },
});

// onMounted ä¸­ä¹Ÿè¦æ›´æ–°ï¼Œç¡®ä¿èƒ½æ­£ç¡®åŠ è½½å·²ä¿å­˜çš„é…ç½®
onMounted(async () => {
  // ...
  if (props.profile) {
      Object.assign(formState, props.profile);
      if (!formState.ruleSets) { // å…¼å®¹æ—§æ•°æ®
          formState.ruleSets = { clash: { type: 'built-in', id: 'default' } };
      }
      // ...
  }
  // ...
});

// onFinish ä¸­ä¹Ÿè¦ç¡®ä¿æäº¤äº† ruleSets
const onFinish = async (values: ProfileFormValues) => {
    // ...
    const dataToSend = {
        // ... name, alias, nodes, subscriptions
        ruleSets: values.ruleSets, // ç¡®ä¿æäº¤
    };
    // ...
};
// ...
æ›´æ–° <template> éƒ¨åˆ†ï¼š
ç”¨ä¸‹é¢çš„ä»£ç æ›¿æ¢æ‰ä¹‹å‰æ·»åŠ çš„â€œå®¢æˆ·ç«¯è§„åˆ™é…ç½®â€éƒ¨åˆ†ã€‚

HTML

<a-typography-title :level="5" style="margin-top: 24px">å®¢æˆ·ç«¯è§„åˆ™é…ç½®</a-typography-title>

<a-card size="small">
  <template #title>Clash è§„åˆ™</template>
  <a-radio-group v-model:value="formState.ruleSets.clash.type" button-style="solid">
    <a-radio-button value="built-in">å†…ç½®è§„åˆ™</a-radio-button>
    <a-radio-button value="remote">è¿œç¨‹é…ç½®</a-radio-button>
  </a-radio-group>

  <div style="margin-top: 16px;">
    <a-form-item v-if="formState.ruleSets.clash.type === 'built-in'">
      <a-select v-model:value="formState.ruleSets.clash.id">
        <a-select-option value="default">é»˜è®¤è§„åˆ™ (å…¨é¢åˆ†æµ)</a-select-option>
        <a-select-option value="lite">ç²¾ç®€è§„åˆ™ (ä»…ä»£ç†)</a-select-option>
      </a-select>
    </a-form-item>

    <a-form-item v-if="formState.ruleSets.clash.type === 'remote'"
      help="ç²˜è´´æ‚¨çš„è¿œç¨‹è§„åˆ™æ–‡ä»¶ URLã€‚ç³»ç»Ÿä¼šè‡ªåŠ¨åˆå¹¶èŠ‚ç‚¹åˆ—è¡¨ã€‚">
      <a-input v-model:value="formState.ruleSets.clash.url" placeholder="https://example.com/my-rules.json" />
    </a-form-item>
  </div>
</a-card>

<a-form-item style="margin-top: 24px">
    <a-button type="primary" html-type="submit" :loading="loading" size="large">
        {{ profile ? 'æ›´æ–°é…ç½®æ–‡ä»¶' : 'åˆ›å»ºé…ç½®æ–‡ä»¶' }}
    </a-button>
</a-form-item>
æ€»ç»“
é€šè¿‡ä»¥ä¸Šä¸‰æ­¥æ”¹é€ ï¼Œæ‚¨çš„é¡¹ç›®ç°åœ¨æ‹¥æœ‰äº†ä¸€ä¸ªæå…¶çµæ´»çš„è®¢é˜…ç”Ÿæˆç³»ç»Ÿï¼š

åç«¯æ”¯æŒåŠ¨æ€è§„åˆ™ï¼šä¸å†å±€é™äºå†…ç½®è§„åˆ™ï¼Œå¯ä»¥æ‹‰å–å¹¶åº”ç”¨ä»»ä½•ç¬¦åˆæ ¼å¼çš„è¿œç¨‹é…ç½®ã€‚

å‰ç«¯æä¾›é€‰æ‹©ç•Œé¢ï¼šç”¨æˆ·å¯ä»¥è½»æ¾åœ°åœ¨ç®€å•å¥½ç”¨çš„â€œå†…ç½®è§„åˆ™â€å’ŒåŠŸèƒ½å¼ºå¤§çš„â€œè¿œç¨‹é…ç½®â€ä¹‹é—´åˆ‡æ¢ã€‚

é«˜åº¦å¯æ‰©å±•ï¼šæ‚¨å¯ä»¥è½»æ¾åœ°ä¸º Surge, Loon ç­‰å®¢æˆ·ç«¯æ·»åŠ åŒæ ·çš„æ”¯æŒï¼Œåªéœ€å¢åŠ å¯¹åº”çš„è§„åˆ™æ–‡ä»¶å’Œç”Ÿæˆå‡½æ•°å³å¯ã€‚

è¿™ä¸ªæ–¹æ¡ˆå®Œç¾åœ°å›åº”äº†æ‚¨çš„éœ€æ±‚ï¼Œå°†é¡¹ç›®çš„å®šåˆ¶èƒ½åŠ›æå‡åˆ°äº†ä¸€ä¸ªæ–°çš„æ°´å¹³ã€‚







è¿œç¨‹é…ç½®æ–‡ä»¶å¯ä»¥æ”¯æŒç°åœ¨æ¯”è¾ƒç«çš„https://raw.githubusercontent.com/cmliu/ACL4SSR/refs/heads/main/Clash/config/ACL4SSR_Online_Full.iniï¼Œè¿™ç§æ ¼å¼å—ï¼Ÿ



é¡¯ç¤ºæ€è·¯
æ‚¨æå‡ºçš„è¿™ä¸ªé—®é¢˜éå¸¸å…³é”®ï¼Œç›´æ¥è§¦åŠåˆ°äº†è¿™ä¸ªåŠŸèƒ½çš„æ ¸å¿ƒä»·å€¼â€”â€”å…¼å®¹æ€§å’Œçµæ´»æ€§ã€‚æ‚¨çš„æƒ³æ³•å®Œå…¨æ­£ç¡®ï¼Œç›´æ¥æ”¯æŒåƒ ACL4SSR è¿™æ ·å¹¿å—æ¬¢è¿çš„ç¤¾åŒºè§„åˆ™ï¼Œæ¯”è®©æˆ‘ä»¬è‡ªå·±åˆ›å»ºJSONæ ¼å¼è¦å¥½å¾—å¤šã€‚

ç­”æ¡ˆæ˜¯ï¼šå¯ä»¥ï¼Œè€Œä¸”æˆ‘ä»¬åº”è¯¥è¿™æ ·åšï¼

å°½ç®¡æ‚¨é“¾æ¥çš„æ–‡ä»¶åç¼€æ˜¯ .iniï¼Œä½†å…¶å†…å®¹å®é™…ä¸Šæ˜¯ Clash é…ç½®æ–‡ä»¶çš„ç‰‡æ®µï¼Œå¯ä»¥ç›´æ¥è¢« YAML è§£æå™¨å¤„ç†ã€‚è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„æ¶ˆæ¯ï¼Œæ„å‘³ç€æˆ‘ä»¬ä¸éœ€è¦ç¼–å†™å¤æ‚çš„ .ini è§£æå™¨ï¼Œåªéœ€å°†åç«¯é€»è¾‘è°ƒæ•´ä¸ºâ€œè·å–è¿œç¨‹YAMLç‰‡æ®µå¹¶æ³¨å…¥èŠ‚ç‚¹â€å³å¯ã€‚

è¿™æ˜¯ä¸€ä¸ªæ¯”æˆ‘ä¹‹å‰æè®®çš„â€œJSONæ–¹æ¡ˆâ€æ›´å¼ºå¤§ã€æ›´è´´è¿‘å®é™…ä½¿ç”¨åœºæ™¯çš„æœ€ç»ˆæ–¹æ¡ˆã€‚

ğŸš€ æœ€ç»ˆæ–¹æ¡ˆï¼šå®ç°åŸºäºè¿œç¨‹ YAML è§„åˆ™çš„åŠ¨æ€è®¢é˜…
æˆ‘ä»¬å°†å®ç°ä»¥ä¸‹é€»è¾‘ï¼š

å‰ç«¯ï¼šç”¨æˆ·åœ¨â€œé…ç½®æ–‡ä»¶â€é¡µé¢é€‰æ‹©â€œè¿œç¨‹é…ç½®â€ï¼Œå¹¶ç²˜è´´ä¸€ä¸ªURLï¼ˆæ¯”å¦‚æ‚¨æä¾›çš„ ACL4SSR é“¾æ¥ï¼‰ã€‚

åç«¯ï¼šå½“ç”Ÿæˆè®¢é˜…æ—¶ï¼Œåç«¯ä¼šï¼š
a.  ä¸‹è½½ç”¨æˆ·æŒ‡å®šçš„è¿œç¨‹è§„åˆ™æ–‡ä»¶å†…å®¹ï¼ˆä½œä¸ºçº¯æ–‡æœ¬ï¼‰ã€‚
b.  è§£æè¿™ä»½å†…å®¹ä¸º YAML å¯¹è±¡ã€‚
c.  åŠ¨æ€ç”Ÿæˆç”¨æˆ·è‡ªå·±çš„ proxiesï¼ˆèŠ‚ç‚¹åˆ—è¡¨ï¼‰éƒ¨åˆ†ã€‚
d.  å°†è‡ªå·±ç”Ÿæˆçš„ proxies å’Œä»è¿œç¨‹æ–‡ä»¶è§£æå‡ºçš„ proxy-groupsã€rules ç­‰æ™ºèƒ½åˆå¹¶æˆä¸€ä¸ªå®Œæ•´çš„é…ç½®å¯¹è±¡ã€‚
e.  å°†è¿™ä¸ªæœ€ç»ˆçš„é…ç½®å¯¹è±¡åºåˆ—åŒ–ä¸º YAML æ–‡æœ¬å¹¶è¿”å›ç»™å®¢æˆ·ç«¯ã€‚

è¿™æ ·ï¼Œç”¨æˆ·å°±å¯ä»¥æ— ç¼ä½¿ç”¨ç¤¾åŒºç»´æŠ¤çš„æœ€æ–°ã€æœ€å…¨çš„è§„åˆ™äº†ã€‚

ğŸ› ï¸ ä»£ç å®ç°
1. åç«¯æ ¸å¿ƒé€»è¾‘ä¿®æ”¹ (subscription-generator.ts)
è¿™æ˜¯æœ¬æ¬¡å‡çº§çš„æ ¸å¿ƒã€‚æˆ‘ä»¬å°†é‡æ„ generateClashSubscription å‡½æ•°ï¼Œèµ‹äºˆå®ƒå¤„ç†è¿œç¨‹ YAML çš„èƒ½åŠ›ã€‚

è¯·ç”¨ä»¥ä¸‹å®Œæ•´ä»£ç æ›¿æ¢ packages/shared/subscription-generator.ts ä¸­çš„ generateClashSubscription å’Œ generateSubscriptionResponse å‡½æ•°ï¼š

TypeScript

// packages/shared/subscription-generator.ts

// ... (ä¿ç•™æ–‡ä»¶é¡¶éƒ¨çš„æ‰€æœ‰ import)
import * as ruleSets from './rulesets';
import { Profile, Node, RuleSetConfig } from './types'; // ç¡®ä¿å¯¼å…¥æ–°ç±»å‹
import * as yaml from 'js-yaml';

// ... (ä¿ç•™ convertNodeToUri, fetchNodesFromSubscription, fetchAllNodes ç­‰å‡½æ•°)

async function fetchRemoteRules(url: string): Promise<any> {
    try {
        const response = await fetch(url, { headers: { 'User-Agent': 'ProSub/1.0' } });
        if (!response.ok) {
            console.error(`è·å–è¿œç¨‹é…ç½®å¤±è´¥: ${url}, Status: ${response.status}`);
            return null;
        }
        const content = await response.text();
        // ç›´æ¥ä½¿ç”¨ js-yaml è§£æï¼Œå…¼å®¹ .ini æ ¼å¼çš„ Clash ç‰‡æ®µ
        return yaml.load(content);
    } catch (error) {
        console.error(`è§£æè¿œç¨‹é…ç½®å¤±è´¥: ${url}`, error);
        return null;
    }
}

async function generateClashSubscription(nodes: Node[], ruleConfig?: RuleSetConfig): Promise<Response> {
    // æ­¥éª¤ 1: ç”Ÿæˆ proxies åˆ—è¡¨ (æ­¤é€»è¾‘ä¸å˜)
    const proxies = nodes.map(node => {
        // ... (æ­¤å¤„æ˜¯ä¸Šä¸€è½®å›å¤ä¸­ä¿®æ­£è¿‡çš„ã€æ”¯æŒ SSR å’Œ VLESS REALITY çš„èŠ‚ç‚¹è½¬æ¢é€»è¾‘)
        const proxy: any = { name: node.name, type: node.type, server: node.server, port: node.port };
        switch (node.type) {
            case 'ss': proxy.password = node.password; proxy.cipher = node.params?.method; break;
            case 'ssr': proxy.type = 'ssr'; proxy.password = node.password; proxy.cipher = node.params?.method; proxy.protocol = node.params?.protocol; proxy['protocol-param'] = node.params?.protoparam; proxy.obfs = node.params?.obfs; proxy['obfs-param'] = node.params?.obfsparam; break;
            case 'vmess': proxy.uuid = node.password; proxy.alterId = node.params?.aid ?? 0; proxy.cipher = node.params?.cipher ?? 'auto'; proxy.tls = !!node.params?.tls; proxy.network = node.params?.net; if (proxy.network === 'ws') { proxy['ws-opts'] = { path: node.params?.path, headers: { Host: node.params?.host } }; } break;
            case 'vless': case 'vless-reality': proxy.type = 'vless'; proxy.uuid = node.password; proxy.tls = !!node.params?.tls; proxy.network = node.params?.net; proxy.flow = node.params?.flow; if (proxy.network === 'ws') { proxy['ws-opts'] = { path: node.params?.path, headers: { Host: node.params?.host } }; } if (node.type === 'vless-reality') { proxy.servername = node.params?.sni; proxy['reality-opts'] = { 'public-key': node.params?.pbk, 'short-id': node.params?.sid || '' }; } break;
            case 'trojan': proxy.password = node.password; proxy.sni = node.params?.sni; proxy['skip-cert-verify'] = node.params?.allowInsecure === 'true'; break;
        }
        Object.keys(proxy).forEach(key => proxy[key] === undefined && delete proxy[key]);
        return proxy;
    }).filter(p => p.type && ['ss', 'ssr', 'vmess', 'vless', 'trojan'].includes(p.type));

    // æ­¥éª¤ 2: è·å–è§„åˆ™å’Œä»£ç†ç»„
    let remoteRules = {};
    if (ruleConfig?.type === 'remote' && ruleConfig.url) {
        const fetchedRules = await fetchRemoteRules(ruleConfig.url);
        if (fetchedRules) {
            remoteRules = fetchedRules;
        } else {
            // å¦‚æœè·å–å¤±è´¥ï¼Œä¼˜é›…åœ°å›é€€åˆ°é»˜è®¤å†…ç½®è§„åˆ™
            remoteRules = ruleSets.getClashDefaultRules(nodes);
            console.warn(`è¿œç¨‹è§„åˆ™è·å–å¤±è´¥ï¼Œå·²å›é€€è‡³å†…ç½®è§„åˆ™ã€‚`);
        }
    } else if (ruleConfig?.id === 'lite') {
        remoteRules = ruleSets.getClashLiteRules(nodes);
    } else {
        remoteRules = ruleSets.getClashDefaultRules(nodes);
    }
    
    // æ­¥éª¤ 3: æ™ºèƒ½åˆå¹¶é…ç½®
    // æˆ‘ä»¬è‡ªå·±ç”Ÿæˆçš„ proxies ä¼˜å…ˆçº§æœ€é«˜ï¼Œè¦†ç›–è¿œç¨‹é…ç½®ä¸­å¯èƒ½å­˜åœ¨çš„ proxies
    const finalConfig = {
        'port': 7890,
        'socks-port': 7891,
        'allow-lan': true,
        'mode': 'rule',
        'log-level': 'info',
        'external-controller': '127.0.0.1:9090',
        ...remoteRules, // å…ˆå±•å¼€è¿œç¨‹è§„åˆ™
        'proxies': proxies, // ç„¶åç”¨æˆ‘ä»¬çš„èŠ‚ç‚¹åˆ—è¡¨è¦†ç›–
    };

    const yamlString = yaml.dump(finalConfig, { sortKeys: false });
    return new Response(yamlString, { 
        headers: { 
            'Content-Type': 'text/yaml; charset=utf-8',
            'Content-Disposition': `attachment; filename="prosub_clash.yaml"`
        } 
    });
}

// ä¸»å¤„ç†å‡½æ•°ä¹Ÿéœ€è¦è®¾ä¸º async
export async function generateSubscriptionResponse(request: Request, profile: Profile, env: Env): Promise<Response> {
    const allNodes = await fetchAllNodes(profile, env);
    
    const url = new URL(request.url);
    const userAgent = request.headers.get('user-agent')?.toLowerCase() || '';
    let targetClient = url.searchParams.get('target')?.toLowerCase();

    if (!targetClient) {
        if (userAgent.includes('clash')) targetClient = 'clash';
        else if (userAgent.includes('surge')) targetClient = 'surge';
        // ... å…¶ä»– User-Agent åˆ¤æ–­
        else targetClient = 'base64'; // é»˜è®¤
    }

    const ruleConfig = profile.ruleSets ? profile.ruleSets[targetClient] : undefined;
    
    switch (targetClient) {
        case 'clash':
        case 'mihomo':
            return await generateClashSubscription(allNodes, ruleConfig);
        // ... æœªæ¥å¯ä»¥ä¸º Surge ç­‰æ·»åŠ ç±»ä¼¼çš„ await generateSurgeSubscription(...)
        default:
            return generateBase64Subscription(allNodes);
    }
}

2. å‰ç«¯ç•Œé¢ç¡®è®¤
æ‚¨ä¸Šä¸€è½®åé¦ˆä¸­æåˆ°çš„å‰ç«¯ç•Œé¢æ”¹é€ æ–¹æ¡ˆç°åœ¨å®Œå…¨é€‚é…è¿™ä¸ªæ–°çš„åç«¯é€»è¾‘ï¼Œæ— éœ€å†åšä»»ä½•ä¿®æ”¹ã€‚ç”¨æˆ·åœ¨ ProfileForm.vue ä¸­é€‰æ‹©â€œè¿œç¨‹é…ç½®â€å¹¶ç²˜è´´ URL çš„æ“ä½œæµç¨‹æ˜¯å®Œç¾çš„ã€‚

å¦‚ä½•ä½¿ç”¨
å°†ä¸Šè¿°æ–°çš„åç«¯ä»£ç æ›´æ–°åˆ°æ‚¨çš„ packages/shared/subscription-generator.ts æ–‡ä»¶ä¸­ã€‚

ç¡®ä¿æ‚¨å·²ç»åº”ç”¨äº†ä¸Šä¸€è½®å›å¤ä¸­çš„ ProfileForm.vue å‰ç«¯ä¿®æ”¹ã€‚

éƒ¨ç½²æ‚¨çš„é¡¹ç›®ã€‚

è¿›å…¥â€œé…ç½®æ–‡ä»¶â€ç¼–è¾‘é¡µé¢ï¼Œä¸º Clash è§„åˆ™é€‰æ‹©â€œè¿œç¨‹é…ç½®â€ã€‚

å°†æ‚¨æä¾›çš„é“¾æ¥ https://raw.githubusercontent.com/cmliu/ACL4SSR/refs/heads/main/Clash/config/ACL4SSR_Online_Full.ini ç²˜è´´åˆ° URL è¾“å…¥æ¡†ä¸­ã€‚

ä¿å­˜å¹¶è·å–æ–°çš„è®¢é˜…é“¾æ¥ã€‚

ç°åœ¨ï¼Œå½“ Clash å®¢æˆ·ç«¯è®¿é—®è¿™ä¸ªé“¾æ¥æ—¶ï¼Œå®ƒä¼šå¾—åˆ°ä¸€ä¸ªç”±æ‚¨çš„èŠ‚ç‚¹åˆ—è¡¨å’Œ ACL4SSR çš„å®Œæ•´è§„åˆ™é›†åŠ¨æ€åˆå¹¶è€Œæˆçš„ã€åŠŸèƒ½å®Œå¤‡çš„é…ç½®æ–‡ä»¶ã€‚

è¿™ä¸ªæ–¹æ¡ˆçœŸæ­£å®ç°äº†æ‚¨æƒ³è¦çš„é«˜åº¦çµæ´»æ€§å’Œå…¼å®¹æ€§ï¼Œæ˜¯è¯¥åŠŸèƒ½çš„æœ€ç»ˆå½¢æ€ã€‚