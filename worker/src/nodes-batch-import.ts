import { authenticateUser } from '@/lib/auth';
import { parseNodeLink } from '@/lib/node-parser';
import { Node } from '@/types';interface Env {  KV: KVNamespace;}export async function handleNodesBatchImport(request: Request, env: Env): Promise<Response> {  const authenticatedUser = await authenticateUser(request, env);  if (!authenticatedUser) {    return new Response(JSON.stringify({ message: '未授权' }), { status: 401, headers: { 'Content-Type': 'application/json' } });  }  try {    const { links } = (await request.json()) as { links: string };    if (!links) {      return new Response(JSON.stringify({ message: '请求体中需要提供 links 字符串' }), { status: 400, headers: { 'Content-Type': 'application/json' } });    }    const linkArray = links.split(/[\r\n]+/).filter(Boolean);    if (linkArray.length === 0) {      return new Response(JSON.stringify({ message: '未提供任何链接' }), { status: 400, headers: { 'Content-Type': 'application/json' } });    }    const KV = env.KV;    const nodeList = await KV.list({ prefix: 'node:' });    const existingNodesJson = await Promise.all(      nodeList.keys.map(async ({ name }) => KV.get(name))    );    const existingNodes: Node[] = existingNodesJson.filter(Boolean).map(json => JSON.parse(json as string));        const existingNodeSet = new Set(      existingNodes.map(node => `${node.server}:${node.port}:${node.password || ''}`)    );    let importedCount = 0;    let skippedCount = 0;    const putPromises: Promise<any>[] = [];    for (const link of linkArray) {      const parsed = parseNodeLink(link);      if (parsed && parsed.server && parsed.port) {        const uniqueKey = `${parsed.server}:${parsed.port}:${parsed.password || ''}`;                if (!existingNodeSet.has(uniqueKey)) {          const newNode = {            id: crypto.randomUUID(),            ...parsed          } as Node;          putPromises.push(KV.put(`node:${newNode.id}`, JSON.stringify(newNode)));          existingNodeSet.add(uniqueKey);           importedCount++;        } else {          skippedCount++;        }      }    }    if (putPromises.length > 0) {      await Promise.all(putPromises);    }        return new Response(JSON.stringify({         message: `导入完成！成功导入 ${importedCount} 个新节点，因服务器、端口和密码重复而跳过 ${skippedCount} 个节点。`     }), { status: 200, headers: { 'Content-Type': 'application/json' } });  } catch (error) {    console.error('Failed to batch import nodes:', error);    return new Response(JSON.stringify({ error: '批量导入节点时发生错误' }), { status: 500, headers: { 'Content-Type': 'application/json' } });  }}